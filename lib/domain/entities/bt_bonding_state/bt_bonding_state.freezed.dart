// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'bt_bonding_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$BtBondingStateTearOff {
  const _$BtBondingStateTearOff();

// ignore: unused_element
  _BtBondingStateConnected bonded() {
    return const _BtBondingStateConnected();
  }

// ignore: unused_element
  _BtBondingStateConnecting bonding() {
    return const _BtBondingStateConnecting();
  }

// ignore: unused_element
  _BtBondingStateDisconnected unbonded() {
    return const _BtBondingStateDisconnected();
  }

// ignore: unused_element
  _BtBondingStateFailure failure() {
    return const _BtBondingStateFailure();
  }
}

// ignore: unused_element
const $BtBondingState = _$BtBondingStateTearOff();

mixin _$BtBondingState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result bonded(),
    @required Result bonding(),
    @required Result unbonded(),
    @required Result failure(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result bonded(),
    Result bonding(),
    Result unbonded(),
    Result failure(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result bonded(_BtBondingStateConnected value),
    @required Result bonding(_BtBondingStateConnecting value),
    @required Result unbonded(_BtBondingStateDisconnected value),
    @required Result failure(_BtBondingStateFailure value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result bonded(_BtBondingStateConnected value),
    Result bonding(_BtBondingStateConnecting value),
    Result unbonded(_BtBondingStateDisconnected value),
    Result failure(_BtBondingStateFailure value),
    @required Result orElse(),
  });
}

abstract class $BtBondingStateCopyWith<$Res> {
  factory $BtBondingStateCopyWith(
          BtBondingState value, $Res Function(BtBondingState) then) =
      _$BtBondingStateCopyWithImpl<$Res>;
}

class _$BtBondingStateCopyWithImpl<$Res>
    implements $BtBondingStateCopyWith<$Res> {
  _$BtBondingStateCopyWithImpl(this._value, this._then);

  final BtBondingState _value;
  // ignore: unused_field
  final $Res Function(BtBondingState) _then;
}

abstract class _$BtBondingStateConnectedCopyWith<$Res> {
  factory _$BtBondingStateConnectedCopyWith(_BtBondingStateConnected value,
          $Res Function(_BtBondingStateConnected) then) =
      __$BtBondingStateConnectedCopyWithImpl<$Res>;
}

class __$BtBondingStateConnectedCopyWithImpl<$Res>
    extends _$BtBondingStateCopyWithImpl<$Res>
    implements _$BtBondingStateConnectedCopyWith<$Res> {
  __$BtBondingStateConnectedCopyWithImpl(_BtBondingStateConnected _value,
      $Res Function(_BtBondingStateConnected) _then)
      : super(_value, (v) => _then(v as _BtBondingStateConnected));

  @override
  _BtBondingStateConnected get _value =>
      super._value as _BtBondingStateConnected;
}

class _$_BtBondingStateConnected implements _BtBondingStateConnected {
  const _$_BtBondingStateConnected();

  @override
  String toString() {
    return 'BtBondingState.bonded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtBondingStateConnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result bonded(),
    @required Result bonding(),
    @required Result unbonded(),
    @required Result failure(),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return bonded();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result bonded(),
    Result bonding(),
    Result unbonded(),
    Result failure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bonded != null) {
      return bonded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result bonded(_BtBondingStateConnected value),
    @required Result bonding(_BtBondingStateConnecting value),
    @required Result unbonded(_BtBondingStateDisconnected value),
    @required Result failure(_BtBondingStateFailure value),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return bonded(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result bonded(_BtBondingStateConnected value),
    Result bonding(_BtBondingStateConnecting value),
    Result unbonded(_BtBondingStateDisconnected value),
    Result failure(_BtBondingStateFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bonded != null) {
      return bonded(this);
    }
    return orElse();
  }
}

abstract class _BtBondingStateConnected implements BtBondingState {
  const factory _BtBondingStateConnected() = _$_BtBondingStateConnected;
}

abstract class _$BtBondingStateConnectingCopyWith<$Res> {
  factory _$BtBondingStateConnectingCopyWith(_BtBondingStateConnecting value,
          $Res Function(_BtBondingStateConnecting) then) =
      __$BtBondingStateConnectingCopyWithImpl<$Res>;
}

class __$BtBondingStateConnectingCopyWithImpl<$Res>
    extends _$BtBondingStateCopyWithImpl<$Res>
    implements _$BtBondingStateConnectingCopyWith<$Res> {
  __$BtBondingStateConnectingCopyWithImpl(_BtBondingStateConnecting _value,
      $Res Function(_BtBondingStateConnecting) _then)
      : super(_value, (v) => _then(v as _BtBondingStateConnecting));

  @override
  _BtBondingStateConnecting get _value =>
      super._value as _BtBondingStateConnecting;
}

class _$_BtBondingStateConnecting implements _BtBondingStateConnecting {
  const _$_BtBondingStateConnecting();

  @override
  String toString() {
    return 'BtBondingState.bonding()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtBondingStateConnecting);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result bonded(),
    @required Result bonding(),
    @required Result unbonded(),
    @required Result failure(),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return bonding();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result bonded(),
    Result bonding(),
    Result unbonded(),
    Result failure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bonding != null) {
      return bonding();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result bonded(_BtBondingStateConnected value),
    @required Result bonding(_BtBondingStateConnecting value),
    @required Result unbonded(_BtBondingStateDisconnected value),
    @required Result failure(_BtBondingStateFailure value),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return bonding(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result bonded(_BtBondingStateConnected value),
    Result bonding(_BtBondingStateConnecting value),
    Result unbonded(_BtBondingStateDisconnected value),
    Result failure(_BtBondingStateFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bonding != null) {
      return bonding(this);
    }
    return orElse();
  }
}

abstract class _BtBondingStateConnecting implements BtBondingState {
  const factory _BtBondingStateConnecting() = _$_BtBondingStateConnecting;
}

abstract class _$BtBondingStateDisconnectedCopyWith<$Res> {
  factory _$BtBondingStateDisconnectedCopyWith(
          _BtBondingStateDisconnected value,
          $Res Function(_BtBondingStateDisconnected) then) =
      __$BtBondingStateDisconnectedCopyWithImpl<$Res>;
}

class __$BtBondingStateDisconnectedCopyWithImpl<$Res>
    extends _$BtBondingStateCopyWithImpl<$Res>
    implements _$BtBondingStateDisconnectedCopyWith<$Res> {
  __$BtBondingStateDisconnectedCopyWithImpl(_BtBondingStateDisconnected _value,
      $Res Function(_BtBondingStateDisconnected) _then)
      : super(_value, (v) => _then(v as _BtBondingStateDisconnected));

  @override
  _BtBondingStateDisconnected get _value =>
      super._value as _BtBondingStateDisconnected;
}

class _$_BtBondingStateDisconnected implements _BtBondingStateDisconnected {
  const _$_BtBondingStateDisconnected();

  @override
  String toString() {
    return 'BtBondingState.unbonded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtBondingStateDisconnected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result bonded(),
    @required Result bonding(),
    @required Result unbonded(),
    @required Result failure(),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return unbonded();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result bonded(),
    Result bonding(),
    Result unbonded(),
    Result failure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unbonded != null) {
      return unbonded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result bonded(_BtBondingStateConnected value),
    @required Result bonding(_BtBondingStateConnecting value),
    @required Result unbonded(_BtBondingStateDisconnected value),
    @required Result failure(_BtBondingStateFailure value),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return unbonded(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result bonded(_BtBondingStateConnected value),
    Result bonding(_BtBondingStateConnecting value),
    Result unbonded(_BtBondingStateDisconnected value),
    Result failure(_BtBondingStateFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unbonded != null) {
      return unbonded(this);
    }
    return orElse();
  }
}

abstract class _BtBondingStateDisconnected implements BtBondingState {
  const factory _BtBondingStateDisconnected() = _$_BtBondingStateDisconnected;
}

abstract class _$BtBondingStateFailureCopyWith<$Res> {
  factory _$BtBondingStateFailureCopyWith(_BtBondingStateFailure value,
          $Res Function(_BtBondingStateFailure) then) =
      __$BtBondingStateFailureCopyWithImpl<$Res>;
}

class __$BtBondingStateFailureCopyWithImpl<$Res>
    extends _$BtBondingStateCopyWithImpl<$Res>
    implements _$BtBondingStateFailureCopyWith<$Res> {
  __$BtBondingStateFailureCopyWithImpl(_BtBondingStateFailure _value,
      $Res Function(_BtBondingStateFailure) _then)
      : super(_value, (v) => _then(v as _BtBondingStateFailure));

  @override
  _BtBondingStateFailure get _value => super._value as _BtBondingStateFailure;
}

class _$_BtBondingStateFailure implements _BtBondingStateFailure {
  const _$_BtBondingStateFailure();

  @override
  String toString() {
    return 'BtBondingState.failure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BtBondingStateFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result bonded(),
    @required Result bonding(),
    @required Result unbonded(),
    @required Result failure(),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return failure();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result bonded(),
    Result bonding(),
    Result unbonded(),
    Result failure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (failure != null) {
      return failure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result bonded(_BtBondingStateConnected value),
    @required Result bonding(_BtBondingStateConnecting value),
    @required Result unbonded(_BtBondingStateDisconnected value),
    @required Result failure(_BtBondingStateFailure value),
  }) {
    assert(bonded != null);
    assert(bonding != null);
    assert(unbonded != null);
    assert(failure != null);
    return failure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result bonded(_BtBondingStateConnected value),
    Result bonding(_BtBondingStateConnecting value),
    Result unbonded(_BtBondingStateDisconnected value),
    Result failure(_BtBondingStateFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class _BtBondingStateFailure implements BtBondingState {
  const factory _BtBondingStateFailure() = _$_BtBondingStateFailure;
}
